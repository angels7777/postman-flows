[[{"l":"Postman Flows"},{"l":"A visual programming language for APIs","p":["Postman Flows is an API workflow builder that lets you connect APIs logically. Use Flows to chain requests, handle data and create real world workflows right in your Postman workspace.","Postman Flow is a beta feature and is available to members of all plans for free. Head on to Postman web app or use the latest version of Postman desktop app to start creating Flows."]},{"l":"Fundamentals","p":["A block is not a function but a process","A Block is the basic unit of flows. There are various kind of blocks, some create data, some process data and some visualize data. In the above example you can see three blocks which are capable of Sending a HTTP request.","A block starts running when a message packet becomes available in all of its connected inputs.","A block to executable when all of it's required inputs are connected.","A Connection is a data pipe which can be used to transfer messages from output of one block to the input of another. Imagined them as FedEx like courier service that transfer mails and parcels between addresses.","A Message is a single packet of data. A message could be a simple string or number, or it could be a large complex data structure like an List of users, or maybe an entire Movie.","A Signal is a special kind of connection that does not carry data but a signal which is triggered when a block completes processing.","Additionally, a flow in itself can be considered as a block.","Connections don't store data, they just transmit.","Data structures like Lists can also be converted to Streams which can be processed by blocks asynchronously.","Message can't be transmitted to an input if it already has a message. Messages wait in the output until the receivers completes processing the existing message.","Signal ports also understand stream, so they donâ€™t turn on until the entire stream has been processed.","There are just 4 fundamental concepts that you need to know before starting to use flows.","To be able to send a request, the block might need some input like variable and it might generate some output like the response. Every block is different but fundamentally it is a black-box process which takes in some input messages,executes and then generates output messages.","Very often execution happens in parallel, but there may be requirements to halt the execution of block until other blocks have completed their execution. In such cases the signal can be used to pause execution and synchronize.","When message flow from one block another, the actual data does not move but a pointer to the message is passed along.","When two connections are connected to the input and both have messages, they don't get merged, the block processes each message in a round-robbin fashion.","When two connections are connected to the output, then a message is duplicated and sent to both connections."]},{"l":"Getting Started","p":["The Interface","The Block Anatomy","Data Types","Expressions & Operators"]},{"l":"Tutorials","p":["Level 1 - Sending a Request","Level 2 - Chaining Requests","Level 3 - Working with Access Tokens","Level 4 - Loops & Lists"]},{"l":"Contribute","p":["Flows is in beta and we're building it actively. We would love to hear what you're making with flows, what issues you face while doing so, and what new you'd like to see in Postman Flows.","Head on over to the discussions page to start or join a conversation"]}],[{"l":"The Interface"},{"l":"Toolbar","p":["The toolbar gives you access to tools you can use to manipulate the canvas.","Use the toolbar to zoom in or out the canvas. Fit-to-view adjusts the zoom level to fit your entire flow on the visible canvas.","You can also hold down ctrl/ cmd scroll to zoom in or out","Use the start button to execute the flow you've built on the canvas. the start button changes to stop during an active run, which can be used to, well, stop the flow.","The tool bar lets you add a block to the canvas as well. Click on the + Block button and you're presented with a list of the available blocks","You can add rich markdown on the canvas to describe what your flow is doing. Just click on the T or Text icon on the toolbar and place the text block on the canvas."]},{"l":"Context bar","p":["The context bar is the place where you'll see more information about your flow and it's current state.","If you have connected the terminal block to any output, you'll see the output being logged in the Terminal section of the context bar. You can specify a group for the terminal and view that specific group from the context bar too.","Similar to the terminal, you can connect the \"Test\" port of a \" Send request\" block to a Test summary block and see the test results in the context panel. Test summary also supports groups like the Terminal.","When your flow encounters an error while running, you can read the logs in the context bar's \"Execution error\" section","You can see the flow ID and add a summary for your flow in the \"Info\" section"]}],[{"l":"The Block","p":["A block is a small actor/process that perform some predefine action. Flows comes in-built with some predefined blocks. A block starts executing when it has some data in all of it's input ports.","This page is maintained as a source of truth for all the blocks that are available within Flows. Use the ideas section of discussion to suggest any modifications in behavior to the existing blocks or any ideas for new blocks."]},{"l":"Anatomy","p":["This is the name of the block","An indicator telling the state of the block: default, running, ran successfully or ran unsuccessfully","Expand the block to view more configurations and information","Contains additional options for the block","This is a required port and needs a connection for the block to be executable","This is an optional port and block will execute even if there is not connection of the port","This is the output port where the result of the block is emitted","These are the quick configuration for blocks. Some configuration may not be shown here.","This is the signal port that can be connected to prevent the execution of the block until the signal turns high.","This is the signal output port that emits a high signal when the block completes its processing."]},{"l":"Stability","p":["The block is an living standard and blocks go through a life-cycle as mentioned below","- This is proposed block that has not been implemented yet.","- This is a block that has been implement, but the API is not stable yet and may change before becoming stable.","- This a block who API's have been frozen and no changes would be made.","- This is a block which is no longer maintained or there is a newer better alternative block available as a replacement.","- This is a block that once existed but is longer is available to be used."]}],[{"l":"Data Types","p":["Stage: 1 - Proposal","Postman Flows in its heart is a dataflow language, which means that there flows understands all kinds of values and associates a type to data. It should also be noted that Flows in a hybrid typed language, which means that it perform static type checking to provide features like auto-complete and early warning, and it also performs some dynamic type checking during execution. Our intention, in the long run, is to move Flows towards being strictly typed language over a period of time.","We are assuming most flow programmers would either be coming from a javascript/typescript background, or it might be their first time programming in an API-First language; therefore we have tried to keep the vocabulary of the types close to javascript/typescript."]},{"l":"Primitive Values","p":["/ab+c/","0..10","1985-04-12T23:20:50.52Z","3.14 4294967295","A range value","A regular expression","bool","double precision 64-bit values or 64bit unsigned integers","Exactly one value null","Example","foo \uD83D\uDE0E bar","null","number","range (pre-proposal)","regex","string","string containing RFC3339 timestamp","string null","symbol","Symbol of various type","timestamp","true","true or false","type","utf-8 encoded characters","What it accepts"]},{"l":"Boolean","p":["The boolean value can contain two symbols true or false as with any programming language. The Boolean type is represented by the symbol bool.","The boolean value gets automatically converted to a number or a string if required.","value","number","string","true","1","'true'","false","0","'false'"]},{"l":"String","p":["The String type is used to represent textual data. It is a utf-8 encoded list of characters. Just like javascript, string in Flows are also immutable, i.e once a string is created, it cannot be modified. But you can always create new strings out of existing string using operators like concat or substring.","\uD83D\uDCA1 Tip: JSON values are of type string. To make sense of that data they serialize needs perform step called parsing to can generate a complex data-structure of primitive types. The Send Request block performs the parsing automatically if the content-type header hints at a JSON body. In cases where this automatic parsing does not take place, one will need to parse the string using the JSON Parse block.","A string value cannot get converted automatically to any other type."]},{"l":"Number","p":["The number type in Flows can represent all kinds of numerical values, like Integers, Decimals, etc. Temporarily, the number internally are stored as javascript numbers, but this is going to change account for 64-bit integers and providing a unified number type.","A number value gets automatically converted to a string or boolean if required.","value","boolean","string","0","false","'0'","3.14","true","'3.14'"]},{"l":"Timestamp","p":["Unlike javascript, Flows consider dates are first-class type and provide a data type for storing dates. Dates are stored in-accordance to RFC 3339.","A timestamp value gets automatically converted to a string or number if required.","value","string","number","1985-04-12T23:20:50.52Z","'1985-04-12T23:20:50.52Z'","482196050520"]},{"l":"Null","p":["A null value represent a reference to non-existent values. Generally, any datatype could contain a null value instead of their actual value. In an API-First world it is very common to find this occurrence. The only possible value for the null type is null.","Because this is so common, in order to prevent null pointer exceptions, Flow performs some deterministic automatic conversion for null value.","value","boolean","string","number","regex","timestamp","false","''","0","/$^/","0000-00-00T00:00:00Z"]},{"l":"Regex","p":["Regular expressions are patterns which can be used to match character combinations in strings. Flows borrows Javascript regular expression implementation. Read More on MDN.","A regex value gets automatically converted to a string if required.","value","string","/$^/","'/$^/'"]},{"i":"range-pre-proposal---tbd","l":"Range (Pre-Proposal) - TBD","p":["Note: Ranges are still in pre-proposal stage and might not be implemented"]},{"l":"Abstract Types","p":["All complex/abstract data-types in Flows are built over the concept of Streams internally."]},{"l":"List","p":["The list data-type represents a stream of ordered values, where values of the same type may occur more than once. You might be familiar with Arrays in javascript, Lists are like arrays but with the constraint that all elements present in the list are of same type.","A typescript equivalent of List would be","A stream of values where all values have the same type"]},{"l":"Tuple","p":["The tuple data-type represent an ordered sequence of finite elements. The values for each element of the tuple can be of different type. Unlike Lists, tuples cannot be an infinite stream, they are of fixed size and their size must be known before hand.","A typescript equivalent of Tuple would be","A fixed stream of values where values have same or different types"]},{"l":"Record","p":["A record is a collection of fields(key-value pair) where the key is of string type and the values can be of different types. These field are fixed in number and follow a particular sequence. If you have some knowledge of C, you will know these are struct.","A typescript equivalent of Record would be","A stream of fields(key:value) where key is string and values have same or different types"]},{"i":"map--dictionary","l":"Map / Dictionary","p":["A map is a collection of fields where the key can be a value of a primitive type and corresponding value can be of any data-type. The constraint here being that all fields must have keys and values of same type.","A typescript equivalent of Map would be","A stream of fields(key:value) where keys are of same type and values are of same type"]}],[{"i":"expressions--operators","l":"Expressions & Operators","p":["Expression and operators are the means why which you can operate over all kinds of data within Flows. There are various kinds of operators that can be combined with data literals and data references to transform or create new data."]},{"l":"Operators","p":["These are operators that flows currently supports"]},{"l":"Comparison Operators","p":["any","bool","datatype","Description","Evaluates to true if left operand is greater than or equal to right operand","Evaluates to true if left operand is greater than right operand","Evaluates to true if left operand is less than or equal to right operand","Evaluates to true if left operand is less than right operand","Evaluates to true if operands are not same","Evaluates to true if operands are same","Evaluates to true if string on left is not a substring of the right","Evaluates to true if string on left is substring of the right","Evaluates to true if the expression if not of the type","Evaluates to true if the expression is of the type","Evaluates to true if the specified field is not present in the Record","Evaluates to true if the specified field is present in the Record","Evaluates to true if the string does not match the regular expression","Evaluates to true if the string matches the regular expression","Left","number string bool timestamp","number timestamp","Operator","record","regex","Result","Right","string"]},{"l":"Logical Operators","p":["Operator","Description","Left","Right","Result","Evaluates to true when both operands evaluate to true","bool","Evaluates to true when either operands evaluate to true","Evaluates to true when operand is false and vice-versa"]},{"l":"Arithmetic Operators","p":["Adds one operand to the other","Decrement the timestamp by the given number of milliseconds","Description","Divides the first INTEGER operand by the second, and returns the remainder","Divides the first operand by the second","Evaluates to a new list by concatenating both operands","Evaluates to a new string by concatenating both operands","Evaluates to a new string by repeated n times","Evaluates to a new tuple by concatenating both operands","Increment the timestamp by the given number of milliseconds","Left","List","Multiplies one operand by the other","number","Operator","Result","Right","string","Subtracts the second operand from the first","timestamp","tuple"]},{"l":"Unary Operators","p":["Operator","Description","Operand","Result","Serialized a structure to a JSON String","record/ list/ map/ tuple","string","Evaluates to the length of the data","string/ record/ list/ map/ tuple","number","Evaluates to the size in bytes of the data"]},{"l":"Query Operators","p":["Operator","Description","Left","Right","Result","Evaluates to a new list where the right expression evaluates to true for the item","list","bool"]},{"l":"Proposals","p":["These operators are in proposal stage and may/may-not be implemented. Please help us make better decision by showing you use-cases in Discussions.","Operator","Description","sort","Evaluates to a sorted list","groupby","Evaluates to a record which contains fields that group a particular list","^","Exponent operator"]}],[{"i":"level-1---sending-a-request","l":"Level 1 - Sending a request"},{"l":"1. Add the Send Request block","p":["Click on the + Block button on the toolbar and select a block from the list to add to your canvas. Alternatively, you can use the shortcut A with canvas in focus."]},{"l":"2. Select a Request","p":["Click on the Add request to send config for the block and select one of the requests present in your workspace.","Flows can only use requests that have been saved in a collection. So create a collection with a request if you have not already done that.","After selecting the request, you may notice a warning on the config about examples. You can ignore that for now, but it will become important in the later tutorials."]},{"i":"3-select-an-environment-optional","l":"3. Select an Environment (optional)","p":["Usually collections and request have their associated environment variables where secrets or environment specific config may be stored. If you have any such environments present select it.","Environment and variable in postman were originally designed for Collection. When using Flows, you will notice few differences.","The environment selected in the top of your workspace has no effect on flows, instead an environment has to be selected for each of the Send Request block","Updating environment,globals, etc using the pm.environment.set APIs in the test and pre-request script have no effect.","Why this breaking change? Read more."]},{"l":"4. Start the Flow","p":["Finally, click on the Start button in the toolbar and you will notice that the block starts executing. If you have not gone through the Fundaments and Block Anatomy yet, now will be a good time.","The input is optional and there is no connection, therefore the block starts running immediately when flow starts. The block header turns blue when it's running, and after the block completes running the header becomes green.","The Send Request block become green even if the response sent by the Send Request block is a non-200 status code, like 403 or 500. Flows tried to remain un-opinionated about HTTP Request or any other block. The success of the block denotes that flows was successfully able to execute the block and in this case send a request and receive a response back."]}],[{"i":"level-2---chaining-requests","l":"Level 2 - Chaining requests","p":["Chaining request is the ability of send one request after another either in serial or parallel."]},{"l":"Simple","p":["If you have a bunch of simple requests that have no dependency on each other but they have to be executed in a particular order, it's as simple as"]},{"l":"1. Add the Send Request blocks","p":["Click on the + Block button on the toolbar and select the Send Request from the list to add to your canvas, then select the request. Repeat this setup until all the requests are added to the canvas."]},{"l":"2. Connect the signals","p":["Click on the grey dot (signal output) of the source block and connect it to signal input of the target block in the order you want the requests to execute. Here, two Create a post are executed in parallel. When both of the request has completed, the Get all posts endpoint is called, and then finally Delete all posts is called.","When a signal connection is made the input become disabled to show that it will get enabled after the previous blocks get enabled.","The signal connection depict exactly the order in which the blocks will be executed.","When using signal no data is passed from one block to another.","Two or more connections can be made to an input. The block will execute only when all signals have got enabled."]},{"l":"3. Start the Flow","p":["Start the flow see them run in the order they are configured!"]},{"l":"Passing Data"},{"l":"1 Add a Send Request block","p":["Click on the + Block button on the toolbar and select the Send Request from the list to add to your canvas, then select the request."]},{"l":"2 Add another Send Request block","p":["Add another Send request block and add the request you want to send the data to here"]},{"l":"3. Pipe the data","p":["Now we need to tell the flow where the data should flow. To do that, COnnect the response output of the first block to the variables input of the second block."]},{"l":"4. Use the variables","p":["To tell the request what to use from the input received, you use variables. Create a template variable in the request where you want the data to fit in. Then in the flow, click on Add Variables, select the name of the variable and assign it data comming in from the input port Variables."]},{"l":"5. Start the Flow","p":["Start the flow and the data will flow through!","The rest of this tutorial is under-construction"]},{"l":"Conditional","p":["There might be situations where we want to conditionally send the second request."]},{"i":"1-add-an-example-to-the-first-request-important","l":"1. Add an Example to the first request. (Important)"},{"i":"2-add-a-condition-block-in-between-the-first-and-second-request","l":"2. Add a Condition block in-between the first and second request."},{"l":"3. Add a truthy expression to conditionally pipe the data from first request to second"},{"l":"4. Start the Flow"}],[{"i":"level-3---working-with-access-tokens-and-durables","l":"Level 3 - Working with access-tokens and durables","p":["This tutorial is under-construction"]},{"l":"1. Add a Send Request block and add the request that gets the access-token"},{"l":"2. Add more requests that need the access-token to work"},{"l":"3. Tag the access-token from the first request as a durable"},{"l":"4. Use the access-token in all the dependent requests"},{"l":"5. Start the Flow"}],[{"i":"level-4---loops--lists","l":"Level 4 - Loops & Lists","p":["This tutorial is under-construction"]}],[{"l":"Assign Variable","p":["21.10.3","21.12.2","Accepts any type of data","Added in v21.10.3","Changes","Data","Deprecated","Description","Emits a Mapstring, string which can be used to generate variables in a Send Request block","Nested records are not supported, the values of the records can only be strings or values that can be casted to a string.","Port","Symbol","The Assign variable can be used to take any type of input data and convert it to a Map containing strings as values, that can be used as a data-variable. The assign variable block is not capable of defining constant string values. If string values are needed the Create Variable block can be used in conjunction with the Merge block.","Use Send Request blocks Assign value to variable feature to set variable values instead.","Variables","Version"]}],[{"l":"Check","p":["Version","Changes","21.11.1","Added in v21.11.1","The Check block accepts input from 2 sources and lets you write expressions with the new Expression input. If the condition resolves to True it passes the data through otherwise burns the data away.","Port","Symbol","Description","Primary","Data which needs to pass through if condition resolves to True","Secondary","Other source of data which does not pass through","Passes data received from Primary input port if the condition resolves to True"]}],[{"l":"Concatenate","p":["Version","Changes","21.09.1","Added in v21.09.1","This block will be removed in the future versions and replace by a more versatile stream processing blocks. Please use with caution!","The Concatenate block can be used to append a element to a List to create a new List.","Port","Symbol","Description","List","Accepts a List","Data","Accepts data to be appended to the List","Group","Emits the new list with element added"]}],[{"l":"Condition","p":["Version","Changes","21.11.1","Added in v21.11.1","The Condition block lets you write expressions with the new Expression input. If the condition resolves to True it passes the data through the \"Accept\" port, and if the expression resolves to False it passes the data through \"Reject\" port","Port","Symbol","Description","Data","Accepts data on which decision is to be made","Accept","Passes data received if the condition resolves to True","Reject","Passes data received if the condition resolves to False"]}],[{"l":"Create Data","p":["Version","Changes","22.01.1","Added in v22.01.1","The Create Data is used for creating all kinds of data, even complex data structure Tuples, Records, Lists and Maps.","Port","Symbol","Description","Data","Accepts some data which can be used to create other data structure","Provides the complex data structure"]}],[{"l":"Create Durables","p":["Version","Changes","21.12.2","Added in v21.12.2","The Create Durables allows bool, number, string and timestamp values to be made durable. Durables or durable data is the data that can persists across multiple connected blocks.","Port","Symbol","Description","Data","Accepts the data whose values can be assigned to durables","Provides newly created durables and the data received from Data input port"]}],[{"l":"Create Variable","p":["21.09.1","21.12.2","Accepts any type of data to trigger the creation","Added in v21.12.2","Changes","Deprecated","Description","Emits a Mapstring, string which can be used to generate variables in a Send Request block","Nested records are not supported, the values of the records can only be strings or values that can be casted to a string.","Port","Symbol","The Create Variable block can be used define a Map containing constant string values.","Trigger","Use Send Request blocks Assign value to variable feature to set variable values instead.","Variables","Version"]}],[{"l":"Delay","p":["Version","Changes","21.09.1","Added in v21.09.1","The delay block can be used to hold a data packet for a fixed duration of time before emitting it out. One of the use-case for this block is to add a delay between two Send Request blocks. It can be considered equivalent to setTimeout in Javascript.","Port","Symbol","Description","Data","Accepts any type of data","Emits any type of data it has accepted"]}],[{"l":"For Each","p":["Version","Changes","21.09.1","Added in v21.09.1","The For Each block is an iterator control flow block that can be used to loop over a List. The block emits each individual element within the list as a separate data packet.","The signal port behaviour of the blocks connected after the For Each block is different. The for each block is special because it generates a stream of data. Each data packet generated from a single list are bracketed under a single stream. So the signal ports of every block down stream only turns to low when the entire stream has been processed.","Port","Symbol","Description","Data","Accepts any type of data which contains a List","datastream","Emits a stream of individual element of the list"]}],[{"l":"Group By","p":["Version","Changes","21.10.4","Added in v21.10.4","The Group By block can be used generate another list by grouping together Records presents in a List based on a value present in one of the selected fields.","Port","Symbol","Description","Data","Accepts data containing a List","Group","Emits the new list with different groups"]}],[{"l":"List Pop","p":["Version","Changes","21.10.4","Added in v21.10.4","The List Pop block can be used to get the last element of a List.","This block will be removed in the future versions and proper operator will be added in expressions. Please use with caution!","Port","Symbol","Description","Data","Accepts data containing a List","Last","Emits the last element of the List","Rest","Emits the list without the last element"]}],[{"l":"Merge","p":["21.10.2","Accepts data containing a Record","Accepts data containing another Record","Added in v21.10.2","Changes","Data","Description","Emits a Record with fields merged","Port","Source","Symbol","Target","The Merge block can be used to recursively merge two Records into a single Record.","Version","When both source and target contain records fields with same name, then target value will be overridden by the source.","You may be tempted to use merge block to synchronize different data source to perform flow control. This is not advisable, instead use Signal Port to perform flow control."]}],[{"l":"Parse JSON","p":["21.09.1","22.01.1","Accepts data containing a json string","Added in v21.09.1","Changes","Data","Description","Emits a parsed data packet of JSON string","JSON","Port","Removed","Stage:","Symbol","The Parse JSON block can be used to parse any JSON string and create a flow data packet to be used in the program.","The Send Request block automatically performs JSON parsing on bodies that have their content-type header set to JSON. This block will only be needed in the off-chance that automatic parsing does not take place in the Send Request block.","Use Send Request block Parse body configuration to force parse response bodies to JSON.","Version"]}],[{"l":"Send Request","p":["Version","Changes","21.09.1","Added in v21.09.1","The Send Request block can be used to send one of the requests defined in a collection inside the current workspace. This is block optionally accept a Record in its variable port and uses it to generate data-variable to satisfy the variables used within the selected Request.","Port","Symbol","Description","Variables","Accepts a Record containing key value pairs which will be converted to the variables. Nested Records will be flattened.","Response","Emits a Record of the response received for this request","Test","Emits a List of all the tests that were executed for this request. No list will be emitted if the request does not contain any tests."]}],[{"l":"Start","p":["Version","Changes","21.09.1","Added in 21.09.1","The Start block is one of the primitive trigger blocks. It can be used to generate an event with a Record containing the timestamp of when it was triggered.","When a new flow is created it comes with a Start block pre-created which in most cases will be the starting point for the flow.","Port","Symbol","Description","Event","Emits a Record containing the timestamp when the block was executed."]}],[{"l":"Terminal","p":["Version","Changes","21.09.1","Added on v21.09.1","The Terminal block can be used to print the data emitted by any port to the terminal panel. This is similar to using console.log in javascript or System.out.println() in Java. It takes data from any port, formats it in yaml and prints it in the screen or standard-output.","Port","Symbol","Description","Data","Accepts any type of data"]}],[{"l":"Test Summary","p":["Version","Changes","21.10.1","Added in v21.10.1","The Test Summary block is special output block like terminal which can accept the data emitted from the test port of Send Request block. The summary of all the assertions can be seen in the Test Summary panel.","Port","Symbol","Description","Test ( test)","input","Accepts a Test List"]}],[{"l":"Validate"},{"l":"Validate","p":["21.09.1","21.11.1","Accepts any type of data.","Added in v21.09.1","Changes","Data ( data)","Deprecated","Description","Emits the accepted data if the validation fails.","Emits the accepted data if the validation passes.","False","input","Port","Stage:","Symbol","The Validate block is a conditional flow control block that routes a data packet to either the true port or false port based on condition. This block uses some information present within the data itself to perform the validation check.","True","Use Condition block to conditionally pass data to the next block instead.","Version"]}],[{"l":"Flows vs javascript"}],[{"i":"frequently-asked-questions","l":"Frequently Asked Questions \uD83E\uDD14"},{"i":"why-are-my-pre-request-and-test-scripts-not-running-in-flows","l":"Why are my pre-request and test scripts not running in flows?","p":["Pre-request and tests are actually running in flows, but environment, globals updated is blocked in flows. The reason for this decision has been explained in the following document. Environment/Global not updating","If you add a console.log you can see you output in the Postman Console and the results of the tests can be viewed by using the Test Summary block."]}]]