[[{"l":"Welcome","p":["Postman Flows is an API workflow builder that lets you connect APIs logically. Use Flows to chain requests, handle data and create real world workflows right in your Postman workspace.","Based on the flow-based programming paradigm, a Flow is made up of several connected \"Blocks\" that each perform an action. Blocks have \"Ports\" on them that receive and transmit data to and from the block.","Postman Flow is a beta feature and is available to members of all plans for free. Head on to Postman web app or use the latest version of Postman desktop app to start creating Flows."]},{"l":"Getting started","p":["You can create a new flow by going to the \"Flows\" tab in the left sidebar","Open flow builder","When you open a new tab you have the Block list already open from which you can select the block to start with. You can open this Block selector by clicking on any blocks port.","Alternatively you can also add a block by clicking on the \"Add block\" button in the toolbar","add block","Once You've created your flow and are ready to execute it, you can click on the start button on the bottom toolbar. This will trigger the flow to start running.","start"]},{"l":"Contribute","p":["Flows is in beta and we're building it actively. We would love to hear what you're making with flows, what issues you face while doing so, and what new you'd like to see in Postman Flows.","Head on over to the discussions page to start or join a conversation"]}],[{"l":"Blocks","p":["A block is a small actor/process that perform some predefine action. Flows comes in-built with some predefined blocks. A block starts executing when it has some data in all of it's input ports.","This page is maintained as a source of truth for all the blocks that are available within Flows. Use the ideas section of discussion to suggest any modifications in behavior to the existing blocks or any ideas for new blocks."]},{"l":"Anatomy","p":["This is the name of the block","An indicator telling the state of the block: default, running, ran successfully or ran unsuccessfully","Expand the block to view more configurations and information","Contains additional options for the block","This is a required port and needs a connection for the block to be executable","This is an optional port and block will execute even if there is not connection of the port","This is the output port where the result of the block is emitted","These are the quick configuration for blocks. Some configuration may not be shown here.","This is the signal port that can be connected to prevent the execution of the block until the signal turns high.","This is the signal output port that emits a high signal when the block completes its processing."]},{"l":"Stability","p":["The block is an living standard and blocks go through a life-cycle as mentioned below","- This is proposed block that has not been implemented yet.","- This is a block that has been implement, but the API is not stable yet and may change before becoming stable.","- This a block who API's have been frozen and no changes would be made.","- This is a block which is no longer maintained or there is a newer better alternative block available as a replacement.","- This is a block that once existed but is longer is available to be used."]}],[{"l":"Assign Variable","p":["21.10.3","21.12.2","Accepts any type of data","Added in v21.10.3","Changes","Data","Deprecated","Description","Emits a Mapstring, string which can be used to generate variables in a Send Request block","Nested records are not supported, the values of the records can only be strings or values that can be casted to a string.","Port","Symbol","The Assign variable can be used to take any type of input data and convert it to a Map containing strings as values, that can be used as a data-variable. The assign variable block is not capable of defining constant string values. If string values are needed the Create Variable block can be used in conjunction with the Merge block.","Use Send Request blocks Assign value to variable feature to set variable values instead.","Variables","Version"]}],[{"l":"Check","p":["Version","Changes","21.11.1","Added in v21.11.1","The Check block accepts input from 2 sources and lets you write expressions with the new Expression input. If the condition resolves to True it passes the data through otherwise burns the data away.","Port","Symbol","Description","Primary","Data which needs to pass through if condition resolves to True","Secondary","Other source of data which does not pass through","Passes data received from Primary input port if the condition resolves to True"]}],[{"l":"Concatenate","p":["Version","Changes","21.09.1","Added in v21.09.1","This block will be removed in the future versions and replace by a more versatile stream processing blocks. Please use with caution!","The Concatenate block can be used to append a element to a List to create a new List.","Port","Symbol","Description","List","Accepts a List","Data","Accepts data to be appended to the List","Group","Emits the new list with element added"]}],[{"l":"Condition","p":["Version","Changes","21.11.1","Added in v21.11.1","The Condition block lets you write expressions with the new Expression input. If the condition resolves to True it passes the data through the \"Accept\" port, and if the expression resolves to False it passes the data through \"Reject\" port","Port","Symbol","Description","Data","Accepts data on which decision is to be made","Accept","Passes data received if the condition resolves to True","Reject","Passes data received if the condition resolves to False"]}],[{"l":"Create Data","p":["Version","Changes","22.01.1","Added in v22.01.1","The Create Data is used for creating all kinds of data, even complex data structure Tuples, Records, Lists and Maps.","Port","Symbol","Description","Data","Accepts some data which can be used to create other data structure","Provides the complex data structure"]}],[{"l":"Create Durables","p":["Version","Changes","21.12.2","Added in v21.12.2","The Create Durables allows bool, number, string and timestamp values to be made durable. Durables or durable data is the data that can persists across multiple connected blocks.","Port","Symbol","Description","Data","Accepts the data whose values can be assigned to durables","Provides newly created durables and the data received from Data input port"]}],[{"l":"Create Variable","p":["21.09.1","21.12.2","Accepts any type of data to trigger the creation","Added in v21.12.2","Changes","Deprecated","Description","Emits a Mapstring, string which can be used to generate variables in a Send Request block","Nested records are not supported, the values of the records can only be strings or values that can be casted to a string.","Port","Symbol","The Create Variable block can be used define a Map containing constant string values.","Trigger","Use Send Request blocks Assign value to variable feature to set variable values instead.","Variables","Version"]}],[{"l":"Delay","p":["Version","Changes","21.09.1","Added in v21.09.1","The delay block can be used to hold a data packet for a fixed duration of time before emitting it out. One of the use-case for this block is to add a delay between two Send Request blocks. It can be considered equivalent to setTimeout in Javascript.","Port","Symbol","Description","Data","Accepts any type of data","Emits any type of data it has accepted"]}],[{"l":"For Each","p":["Version","Changes","21.09.1","Added in v21.09.1","The For Each block is an iterator control flow block that can be used to loop over a List. The block emits each individual element within the list as a separate data packet.","The signal port behaviour of the blocks connected after the For Each block is different. The for each block is special because it generates a stream of data. Each data packet generated from a single list are bracketed under a single stream. So the signal ports of every block down stream only turns to low when the entire stream has been processed.","Port","Symbol","Description","Data","Accepts any type of data which contains a List","datastream","Emits a stream of individual element of the list"]}],[{"l":"Group By","p":["Version","Changes","21.10.4","Added in v21.10.4","The Group By block can be used generate another list by grouping together Records presents in a List based on a value present in one of the selected fields.","Port","Symbol","Description","Data","Accepts data containing a List","Group","Emits the new list with different groups"]}],[{"l":"List Pop","p":["Version","Changes","21.10.4","Added in v21.10.4","The List Pop block can be used to get the last element of a List.","This block will be removed in the future versions and proper operator will be added in expressions. Please use with caution!","Port","Symbol","Description","Data","Accepts data containing a List","Last","Emits the last element of the List","Rest","Emits the list without the last element"]}],[{"l":"Merge","p":["21.10.2","Accepts data containing a Record","Accepts data containing another Record","Added in v21.10.2","Changes","Data","Description","Emits a Record with fields merged","Port","Source","Symbol","Target","The Merge block can be used to recursively merge two Records into a single Record.","Version","When both source and target contain records fields with same name, then target value will be overridden by the source.","You may be tempted to use merge block to synchronize different data source to perform flow control. This is not advisable, instead use Signal Port to perform flow control."]}],[{"l":"Parse JSON","p":["21.09.1","22.01.1","Accepts data containing a json string","Added in v21.09.1","Changes","Data","Description","Emits a parsed data packet of JSON string","JSON","Port","Removed","Stage:","Symbol","The Parse JSON block can be used to parse any JSON string and create a flow data packet to be used in the program.","The Send Request block automatically performs JSON parsing on bodies that have their content-type header set to JSON. This block will only be needed in the off-chance that automatic parsing does not take place in the Send Request block.","Use Send Request block Parse body configuration to force parse response bodies to JSON.","Version"]}],[{"l":"Send Request","p":["Version","Changes","21.09.1","Added in v21.09.1","The Send Request block can be used to send one of the requests defined in a collection inside the current workspace. This is block optionally accept a Record in its variable port and uses it to generate data-variable to satisfy the variables used within the selected Request.","Port","Symbol","Description","Variables","Accepts a Record containing key value pairs which will be converted to the variables. Nested Records will be flattened.","Response","Emits a Record of the response received for this request","Test","Emits a List of all the tests that were executed for this request. No list will be emitted if the request does not contain any tests."]}],[{"l":"Start","p":["Version","Changes","21.09.1","Added in 21.09.1","The Start block is one of the primitive trigger blocks. It can be used to generate an event with a Record containing the timestamp of when it was triggered.","When a new flow is created it comes with a Start block pre-created which in most cases will be the starting point for the flow.","Port","Symbol","Description","Event","Emits a Record containing the timestamp when the block was executed."]}],[{"l":"Terminal","p":["Version","Changes","21.09.1","Added on v21.09.1","The Terminal block can be used to print the data emitted by any port to the terminal panel. This is similar to using console.log in javascript or System.out.println() in Java. It takes data from any port, formats it in yaml and prints it in the screen or standard-output.","Port","Symbol","Description","Data","Accepts any type of data"]}],[{"l":"Test Summary","p":["Version","Changes","21.10.1","Added in v21.10.1","The Test Summary block is special output block like terminal which can accept the data emitted from the test port of Send Request block. The summary of all the assertions can be seen in the Test Summary panel.","Port","Symbol","Description","Test ( test)","input","Accepts a Test List"]}],[{"l":"Validate"},{"l":"Validate","p":["21.09.1","21.11.1","Accepts any type of data.","Added in v21.09.1","Changes","Data ( data)","Deprecated","Description","Emits the accepted data if the validation fails.","Emits the accepted data if the validation passes.","False","input","Port","Stage:","Symbol","The Validate block is a conditional flow control block that routes a data packet to either the true port or false port based on condition. This block uses some information present within the data itself to perform the validation check.","True","Use Condition block to conditionally pass data to the next block instead.","Version"]}],[{"l":"Data Types","p":["Stage: 1 - Proposal","Postman Flows in its heart is a dataflow language, which means that there flows understands all kinds of values and associates a type to data. It should also be noted that Flows in a hybrid typed language, which means that it perform static type checking to provide features like auto-complete and early warning, and it also performs some dynamic type checking during execution. Our intention, in the long run, is to move Flows towards being strictly typed language over a period of time.","We are assuming most flow programmers would either be coming from a javascript/typescript background, or it might be their first time programming in an API-First language; therefore we have tried to keep the vocabulary of the types close to javascript/typescript."]},{"l":"Primitive Values","p":["/ab+c/","0..10","1985-04-12T23:20:50.52Z","3.14 4294967295","A range value","A regular expression","bool","double precision 64-bit values or 64bit unsigned integers","Exactly one value null","Example","foo \uD83D\uDE0E bar","null","number","range (pre-proposal)","regex","string","string containing RFC3339 timestamp","string null","symbol","Symbol of various type","timestamp","true","true or false","type","utf-8 encoded characters","What it accepts"]},{"l":"Boolean","p":["The boolean value can contain two symbols true or false as with any programming language. The Boolean type is represented by the symbol bool.","The boolean value gets automatically converted to a number or a string if required.","value","number","string","true","1","'true'","false","0","'false'"]},{"l":"String","p":["The String type is used to represent textual data. It is a utf-8 encoded list of characters. Just like javascript, string in Flows are also immutable, i.e once a string is created, it cannot be modified. But you can always create new strings out of existing string using operators like concat or substring.","\uD83D\uDCA1 Tip: JSON values are of type string. To make sense of that data they serialize needs perform step called parsing to can generate a complex data-structure of primitive types. The Send Request block performs the parsing automatically if the content-type header hints at a JSON body. In cases where this automatic parsing does not take place, one will need to parse the string using the JSON Parse block.","A string value cannot get converted automatically to any other type."]},{"l":"Number","p":["The number type in Flows can represent all kinds of numerical values, like Integers, Decimals, etc. Temporarily, the number internally are stored as javascript numbers, but this is going to change account for 64-bit integers and providing a unified number type.","A number value gets automatically converted to a string or boolean if required.","value","boolean","string","0","false","'0'","3.14","true","'3.14'"]},{"l":"Timestamp","p":["Unlike javascript, Flows consider dates are first-class type and provide a data type for storing dates. Dates are stored in-accordance to RFC 3339.","A timestamp value gets automatically converted to a string or number if required.","value","string","number","1985-04-12T23:20:50.52Z","'1985-04-12T23:20:50.52Z'","482196050520"]},{"l":"Null","p":["A null value represent a reference to non-existent values. Generally, any datatype could contain a null value instead of their actual value. In an API-First world it is very common to find this occurrence. The only possible value for the null type is null.","Because this is so common, in order to prevent null pointer exceptions, Flow performs some deterministic automatic conversion for null value.","value","boolean","string","number","regex","timestamp","false","''","0","/$^/","0000-00-00T00:00:00Z"]},{"l":"Regex","p":["Regular expressions are patterns which can be used to match character combinations in strings. Flows borrows Javascript regular expression implementation. Read More on MDN.","A regex value gets automatically converted to a string if required.","value","string","/$^/","'/$^/'"]},{"i":"range-pre-proposal---tbd","l":"Range (Pre-Proposal) - TBD","p":["Note: Ranges are still in pre-proposal stage and might not be implemented"]},{"l":"Abstract Types","p":["All complex/abstract data-types in Flows are built over the concept of Streams internally."]},{"l":"List","p":["The list data-type represents a stream of ordered values, where values of the same type may occur more than once. You might be familiar with Arrays in javascript, Lists are like arrays but with the constraint that all elements present in the list are of same type.","A typescript equivalent of List would be","A stream of values where all values have the same type"]},{"l":"Tuple","p":["The tuple data-type represent an ordered sequence of finite elements. The values for each element of the tuple can be of different type. Unlike Lists, tuples cannot be an infinite stream, they are of fixed size and their size must be known before hand.","A typescript equivalent of Tuple would be","A fixed stream of values where values have same or different types"]},{"l":"Record","p":["A record is a collection of fields(key-value pair) where the key is of string type and the values can be of different types. These field are fixed in number and follow a particular sequence. If you have some knowledge of C, you will know these are struct.","A typescript equivalent of Record would be","A stream of fields(key:value) where key is string and values have same or different types"]},{"i":"map--dictionary","l":"Map / Dictionary","p":["A map is a collection of fields where the key can be a value of a primitive type and corresponding value can be of any data-type. The constraint here being that all fields must have keys and values of same type.","A typescript equivalent of Map would be","A stream of fields(key:value) where keys are of same type and values are of same type"]}],[{"i":"expressions--operators","l":"Expressions & Operators","p":["Expression and operators are the means why which you can operate over all kinds of data within Flows. There are various kinds of operators that can be combined with data literals and data references to transform or create new data."]},{"l":"Operators","p":["These are operators that flows currently supports"]},{"l":"Comparison Operators","p":["any","bool","datatype","Description","Evaluates to true if left operand is greater than or equal to right operand","Evaluates to true if left operand is greater than right operand","Evaluates to true if left operand is less than or equal to right operand","Evaluates to true if left operand is less than right operand","Evaluates to true if operands are not same","Evaluates to true if operands are same","Evaluates to true if string on left is not a substring of the right","Evaluates to true if string on left is substring of the right","Evaluates to true if the expression if not of the type","Evaluates to true if the expression is of the type","Evaluates to true if the specified field is not present in the Record","Evaluates to true if the specified field is present in the Record","Evaluates to true if the string does not match the regular expression","Evaluates to true if the string matches the regular expression","Left","number string bool timestamp","number timestamp","Operator","record","regex","Result","Right","string"]},{"l":"Logical Operators","p":["Operator","Description","Left","Right","Result","Evaluates to true when both operands evaluate to true","bool","Evaluates to true when either operands evaluate to true","Evaluates to true when operand is false and vice-versa"]},{"l":"Arithmetic Operators","p":["Adds one operand to the other","Decrement the timestamp by the given number of milliseconds","Description","Divides the first INTEGER operand by the second, and returns the remainder","Divides the first operand by the second","Evaluates to a new list by concatenating both operands","Evaluates to a new string by concatenating both operands","Evaluates to a new string by repeated n times","Evaluates to a new tuple by concatenating both operands","Increment the timestamp by the given number of milliseconds","Left","List","Multiplies one operand by the other","number","Operator","Result","Right","string","Subtracts the second operand from the first","timestamp","tuple"]},{"l":"Unary Operators","p":["Operator","Description","Operand","Result","Serialized a structure to a JSON String","record/ list/ map/ tuple","string","Evaluates to the length of the data","string/ record/ list/ map/ tuple","number","Evaluates to the size in bytes of the data"]},{"l":"Query Operators","p":["Operator","Description","Left","Right","Result","Evaluates to a new list where the right expression evaluates to true for the item","list","bool"]},{"l":"Proposals","p":["These operators are in proposal stage and may/may-not be implemented. Please help us make better decision by showing you use-cases in Discussions.","Operator","Description","sort","Evaluates to a sorted list","groupby","Evaluates to a record which contains fields that group a particular list","^","Exponent operator"]}],[{"i":"frequently-asked-questions","l":"Frequently Asked Questions \uD83E\uDD14"},{"i":"why-are-my-pre-request-and-test-scripts-not-running-in-flows","l":"Why are my pre-request and test scripts not running in flows?","p":["Pre-request and tests are actually running in flows, but environment, globals updated is blocked in flows. The reason for this decision has been explained in the following document. Environment/Global not updating","If you add a console.log you can see you output in the Postman Console and the results of the tests can be viewed by using the Test Summary block."]}]]